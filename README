This repository uses Flask-Migrate for database schema changes. The
`scripts/migrate_tenants.py` script upgrades all tenant databases by
iterating over domains stored in `master_company` and running Alembic
`upgrade` on each.

from app import create_app, db
from flask_migrate import Migrate, upgrade
from sqlalchemy import text
from flask import current_app

# Step 1: Connect to central database (holding tenants list)
CENTRAL_DB_URI = "sqlite:///instance/app.db"  # Replace with your actual main DB

def get_all_tenants():
    """Fetch tenants and their DB URIs from central tenant table"""
    app = create_app(db_uri_override=CENTRAL_DB_URI)
    with app.app_context():
        result = db.session.execute(text("SELECT name, db_uri FROM tenants"))
        return result.fetchall()

def migrate_tenant(tenant_name, db_uri):
    print(f"üîÅ Migrating tenant: {tenant_name}")
    app = create_app(db_uri_override=db_uri)
    migrate = Migrate(app, db)
    with app.app_context():
        upgrade()

if __name__ == '__main__':
    tenants = get_all_tenants()
    for row in tenants:
        migrate_tenant(row.name, row.db_uri)

    # Optionally run main app
    app = create_app()
      app.run(debug=True)

## Migrating to a tenant database

1. Add each tenant domain to the `master_company` table. The migration
   script uses the domain name to build the path of the SQLite database
   under `tenant_dbs/`.
2. Run the migration script to apply Alembic upgrades for every tenant:

   ```bash
   python scripts/migrate_tenants.py
   ```

   If you recreated the `migrations` folder, stamp each tenant database
   to the latest revision before running the script:

   ```bash
   FLASK_APP=main.py SQLALCHEMY_DATABASE_URI=sqlite:///tenant_dbs/<tenant>.db \
       flask db stamp head
   ```

   The helper script automatically stamps a tenant DB to the base
   revision (`df0745a851cf`) if it has never been migrated. This
   prevents "table already exists" errors during the first upgrade.

3. If a tenant database does not yet exist, create it using
   `app.utils.database_utils.create_company_schema()` before running the
   migrations.
4. Once migrations complete you can start the application normally with
   `python main.py`.

## Switching to MySQL in production

Set the ``SQLALCHEMY_DATABASE_URI`` environment variable before starting the
app to override the default SQLite database. For example:

```bash
export SQLALCHEMY_DATABASE_URI='mysql+pymysql://mleasd:%40T%40_%24Ciy2kTSg_t@mleasd.mysql.pythonanywhere-services.com/mleasd$accounts'

```





export SQLALCHEMY_DATABASE_URI='mysql+pymysql://mleasd:%40T%40_%24Ciy2kTSg_t@mleasd.mysql.pythonanywhere-services.com/mleasd$accounts'


Before running the application on MySQL for the first time, initialise the
schema with Alembic:

```bash
FLASK_APP=main.py flask db upgrade
```

This creates the ``master_company`` and other core tables in the new
database.



When this variable is unset the application falls back to the local
``instance/app.db`` SQLite file for development.

## Purchase numbers for invoice lines

Invoice line items automatically receive a unique purchase number once
they are created. The number uses the invoice and line IDs in the format
`P0001XX` and is ensured again during invoice finalisation. This allows
each line to be reconciled or processed for payment individually.
